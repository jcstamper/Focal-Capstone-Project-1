b'<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE workbook_page PUBLIC "-//Carnegie Mellon University//DTD Workbook Page MathML 3.8//EN" "http://oli.web.cmu.edu/dtd/oli_workbook_page_mathml_3_8.dtd"><workbook_page xmlns:bib="http://bibtexml.sf.net/" xmlns:cmd="http://oli.web.cmu.edu/content/metadata/2.1/" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pref="http://oli.web.cmu.edu/preferences/" xmlns:theme="http://oli.web.cmu.edu/presentation/" xmlns:wb="http://oli.web.cmu.edu/activity/workbook/" id="c492fd6d2f584b22b1311575a6b5f34f"><head><title>Data Structures</title><objref idref="bf93db74e7e8476e9ac073dfa27836f6" /></head><body><section id="f4852029d9184fb08942cecff9434ed7"><title>Abstract Data Types</title><body><p id="f77972a0e50f4d5d90bec7bcdd6ae99f">When we design algorithms, we need to represent data items based on what is expected of them in terms of functionality in a formal abstract or mathematical sense. For example, we may need to represent our data as a set as in mathematics because the operations we will involve them in are things we normally do with sets:</p><ul id="b42037f86c9f40ba8d0b92ae5559d42a"><li><p id="e5a087d2e3514e37a6488e568d81ee28">inserting an element into a set</p></li><li><p id="d8f2a8b78a854c25bef4497a18cd55d1">deleting an element from a set</p></li><li><p id="fadd9fc0984843798e9f9572a050b49c">intersecting, unionizing two sets</p></li><li><p id="a068168e0a524e62845d185e3411a9ec">subtracting a set from another set</p></li><li><p id="b4bd2650085944b89c4308d11d111f46">testing whether a set is equal to another one or is a subset of another one </p></li><li><p id="a8d585e9e4904ddeb181bf21c5fd4bba">testing if a set contains a certain element</p></li></ul><p id="b3ff2d970c3a4343b442b5cc7377ec10">Note that we have intentionally not said anything about what kind of an element a set contains. In fact, sets do not really care what types of elements are stored in them, except that they expect at least that you can test if two such elements are equal or not. In a way, we have abstracted sets from what is contained in them. </p><p id="d5a9cc2c917c4ba18dbd90d2f674fc99">Modern computers provide standard representations for data such as <em style="italic">integers</em>, and <em style="italic">floating point numbers</em>, which are approximations to their mathematical analogs of mathematical integers and real numbers, differing only in the range or the precision of the numbers that can be represented. Our sets can be sets of integers or real numbers or any other structured data we can build from these, e.g., complex numbers, etc.</p><p id="c31c7fb1c36745b2b5ab01747383db56">What is important for an abstract data type description are the following:</p><ul id="b6a78595e9724ae8a104ece3ae4d35a1"><li><p id="d59b46e3b1fb4347a58c6873785d4c2e">What are the mathematical descriptions of each of the operations one can do?</p></li><li><p id="eb971694ed78448db435408db361418c">What are the types of data items that are input to each operation? </p></li><li><p id="ec2a048a4cb24f87bdbac6946cb35842">What are the types of data items that are output from each operation?</p></li></ul><p id="a604773275bc416fbe455ba2bded9756">For instance, for the first operation above, we input an element and set and get a new set which is guaranteed to contain the given element after the operation. For intersection, we get two sets and return a set of only those elements that are in both of the given sets. Finally, for the last two operations, the output is of a binary-valued boolean type whose values can be <em style="italic">true</em> or <em style="italic">false</em>. Note that these specifications are independent of what the type elements are in the sets or how the sets are represented, or how each operation is implemented in code.</p><p id="dfdc85e69696449ca19b52e16b4856ef">So ideally, the programmer decides on the abstract data types that will be used in the algorithmic solution to a problem by concentrating on the operations that will be needed. At this point, she does not need to worry about how those data structures are represented in detail and how the operations are implemented.</p><p id="f40c6df1514a4beb8eabbae6dbb07bb0">The most important idea one should remember about abstract data types is that <em>abstract data types determine functionality</em>. Functionality is the most important aspect of an abstract data type that any user of that abstract data type (i.e., a client programmer) needs to know. This is communicated through typically an API that names the operations and the input-output data to each call in the API along with some description of what function that call provides.</p></body></section><section id="e2ed3114c86f4f498256e91cb672c2e5"><title>Concrete Data Structures</title><body><p id="f08b9e5059774cbe9fc98b47e80585b4">A data structure specifies how data of an abstract data type is represented and how the operations are implemented. For example, a set can be represented in many different ways:</p><ul id="b54259b1136e47af85f1715bc220652b"><li><p id="fee98f3dcbfe41ceabeaecd74561215d">We can represent a set as an array of elements. This is an efficient representation in terms of the memory required. On the other hand, many of the operations would be very inefficient. inefficiently. For example, to decide if the set contains a certain element, we have to start at the beginning and systematically compare it to every element in the array until we either locate it or exhaust the array. Other operations, such as the intersection of two sets or the insertion of a new element, would have additional complications in terms of steps required or memory allocated to represent the set. Yet, with suitable coding, all the operations can be implemented, but in this case, almost all operations would require a number of steps that is proportional either to the number of elements in the set (e.g., insertion or search) or is proportional to the product of the sizes of each set (e.g., intersection).</p><p id="b69244a7ab5d4c33949584b8fb77c96b">We leave it as an exercise to see how much time these operations would take if one implemented a set as a <em style="italic">sorted</em> array.</p></li><li><p id="aba13fc423164133b1730c3a171bcde8">We can represent a set as a hash table. Hash tables consume additional memory in addition to the memory required to store the data but allow for a search for any element based on its key in <em style="italic">expected</em> constant time. So if you plan to do a lot of searching most of the time, that will be desirable. You can also insert new elements or delete old elements from a set in the <em style="italic">expected</em> constant time. However, the intersection of two sets would take a comparatively longer time, and so is the operation of finding the element with the minimum value.</p></li></ul><p id="b758c757ea8e408d85291dedc4a07e0d">There are many other concrete data structures that one can use to implement the abstract data type for sets.</p><p id="a7d46ae4e0d840a8828e15d814a9e967">Similarly, a specific concrete data structure can be used to implement multiple abstract data sets. For example, a pair of real numbers as a concrete structure can implement:</p><ul id="bfa834176c7a41e6a72fe5a6fd555f08"><li><p id="bd037aea6fbc4ac899dd6a003729ff38">Complex numbers, where the pair either encodes the real and imaginary parts of a cartesian representation OR the magnitude and the argument of a polar representation of a complex number. All operations on complex numbers (e.g., exponentiation of a complex number to a complex number) would then be implemented in the said representations.</p></li><li><p id="ed1d3073c5a2446d883e1fd0b377c2ac">Two-dimensional vectors in a cartesian vector space where the two numbers represent the components of a vector along the x and y axes. One can then implement operations such as vector addition or the dot product of two vectors using this representation.</p></li></ul><p id="ab68eda342304c2380b2683a0d9eeba8">Note that it is the abstract data type that determines what operations to be done on the concrete representations are sensible or not. For instance, exponentiation of a complex number to a complex number makes sense in the domain of complex numbers but not in the domain of two-dimensional vectors, and similarly, the dot product of two vectors does not make sense in the domain of complex numbers, even though in both cases the very underlying concrete representations are the same.</p><p id="b15f0366295c431eb5ebf396072d5a33">The important point to remember about concrete data structures is that they are used to implement abstract data types correctly, but this implementation determines the cost of the abstract data.</p></body></section></body></workbook_page>\n'