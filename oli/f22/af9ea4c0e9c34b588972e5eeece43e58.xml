b'<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE workbook_page PUBLIC "-//Carnegie Mellon University//DTD Workbook Page MathML 3.8//EN" "http://oli.web.cmu.edu/dtd/oli_workbook_page_mathml_3_8.dtd"><workbook_page xmlns:bib="http://bibtexml.sf.net/" xmlns:cmd="http://oli.web.cmu.edu/content/metadata/2.1/" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pref="http://oli.web.cmu.edu/preferences/" xmlns:theme="http://oli.web.cmu.edu/presentation/" xmlns:wb="http://oli.web.cmu.edu/activity/workbook/" id="af9ea4c0e9c34b588972e5eeece43e58"><head><title>Types of Sparse Matrices</title><objref idref="b3d107cf419c4e72b8ea40f46073aa09" /><objref idref="d0811aed62d244dab90df3e50cbe8419" /></head><body><p id="a7722a8a4eee42bc89a99bd0851243ec">Throughout this section, we will make use of the following matrix as an example:</p><image id="ba79377e27bd4a36bd298d57e9465941" src="../webcontent/image-af9ea4c0e9c34b588972e5eeece43e58-1.png" alt="" style="inline" vertical-align="middle" height="179" width="315"><caption><p id="fc25b14783184f349db581b7f027ea56" /></caption><popout enable="false"></popout></image><p id="f1277cd6b8e4459aa908bae21e9cb1b8">We refer to the above representation, where the entire matrix with missing values is written out, as the <em style="italic">dense matrix format</em>. Equivalent representations of A as a sparse matrix instead aim to store only the non-zero (non-empty) values and operate on them, as described below. Note that to be consistent with common library implementations, we will use <em>zero-based indexing</em> when referring to row and column indices. </p><section id="a28516ee605c41c2af5929dc0f3d762b"><title>Coordinate Format (COO)</title><body><p id="f28d26c8bbbd46ce9a704c0f27cd6179">COO is a straightforward that stores a matrix as three lists: a list of non-zero values, a list of the non-zero values\xe2\x80\x99 row indices, and a list of the non-zero values\xe2\x80\x99 column indices. In this way, the matrix A is represented as a tuple of three lists (in addition to the matrix shape):</p><codeblock id="b35f16e101fe4dca8c2621687072d61d" syntax="text" highlight="" number="false" start=""><![CDATA[data = [7, 5, 1, 3, 2, 8]\ncol = [2, 4, 0, 2, 4, 3]\nrow = [0, 0, 2, 2, 3, 4]]]></codeblock><p id="fa70140b648140bc9c9971bca295941a">Here <code><![CDATA[data[i]]]></code>, <code><![CDATA[row[i]]]></code> and <code><![CDATA[col[i]]]></code> represent the actual value, row index, and column index of the i-th non-zero value in the matrix respectively. Note that although we say i-th value, there is no ordering constraint here \xe2\x80\x93 the non-zero values can be arranged in any other in <code><![CDATA[data]]></code>, as long as their row and column indices are also arranged accordingly.</p><p id="e92b0836cbac4677a163314cc133311e">Updating entries in COO is simple: new entries can be appended to the end of the three lists while zeroing an entry means finding its locations in the three lists and removing those data points. COO doesn\xe2\x80\x99t support efficient arithmetic operations, but it can be quickly converted to other sparse formats that support these operations.</p></body></section><section id="c805ef2ddef34428bc4ae0e40902a6c2"><title>Dictionary of Keys (DOK)</title><body><p id="a6112156cfe944d28819153173953fa0">DOK uses a dictionary representation that maps the location (row index and column index) of every non-zero element to its value. With the example matrix A,</p><image id="e018d3a6c36a4ec386fbac04e4b2a7dc" src="../webcontent/image-af9ea4c0e9c34b588972e5eeece43e58-2.png" alt="" style="inline" vertical-align="middle" height="179" width="315"><caption><p id="a1af0165a7084a069fda62aa676ea621" /></caption><popout enable="false"></popout></image><p id="e77089d037964760a2f21e64e3766c1d">its DOK representation is</p><codeblock id="ce71d4bab5494151bf9e09523d121676" syntax="text" highlight="" number="false" start=""><![CDATA[{\n\t(2, 0) : 7, (4, 0) : 5, (0, 2) : 1,\n\t(2, 2) : 3, (4, 3) : 2, (3, 4) : 8\n}]]></codeblock><p id="f189f05003114a4895b89a1f5d8a5050">This format allows for fast element access by row and column index. It can also be quickly converted to and from the COO format, although it doesn\xe2\x80\x99t support efficient arithmetic operations.</p></body></section><section id="ef83d22597824817a08437240b22ae93"><title>Compressed Sparse Row Format (CSR)</title><body><p id="ff3a2a834b354fcdbd6844a1079a4689">The compressed sparse row format stores a matrix as three lists:</p><ul id="bb6e4b8463c44f8780cf48753886a23d"><li><p id="e8d656f8a3184344b35a25ddded3f330"><code><![CDATA[data]]></code>: a list of the non-zero values in the matrix</p></li><li><p id="efc10a2281db4a6f8bd6e77f16819f16"><code><![CDATA[col]]></code>: a list of the column indices of the non-zero values</p></li><li><p id="a819b6ab559849a88e275739661139a3"><code><![CDATA[row]]></code>: a list of <em style="italic">m+1</em> values, where m is the number of rows in the original matrix. </p><p id="d65e91ad445646a4961e03076597685e"><code><![CDATA[row[i]]]></code> denotes the number of non-zero entries that appear in the rows above the i-th row in the original matrix, where row indexes start from 0, and <code><![CDATA[row[m]]]></code> denotes the number of non-zero entries in the entire matrix.</p></li></ul><p id="bc9290b0e2364a7692ec94df39790ed0">With the example matrix A,</p><image id="a2b474b546164896bb8d6756c98e27c2" src="../webcontent/image-af9ea4c0e9c34b588972e5eeece43e58-3.png" alt="" style="inline" vertical-align="middle" height="179" width="315"><caption><p id="ba401390f16c46d48183cdc7ebd89ffe" /></caption><popout enable="false"></popout></image><p id="a3ef9b92c34942758cf9594928256c2d">its CSR representation is</p><codeblock id="fb4d16f5b4bf46b086fb7ec2183bbc80" syntax="text" highlight="" number="false" start=""><![CDATA[data = [7, 5, 1, 3, 8, 2]\ncol = [2, 4, 0, 2, 3, 4]\nrow = [0, 2, 2, 4, 6]]]></codeblock></body></section><p id="d405fa039bbc41da91e73cba093bde1c">While the <code><![CDATA[data]]></code> and <code><![CDATA[col]]></code> lists are the same as COO, notice that the row column contains:</p><ol id="f33986f9c4ac4b9a9666ffe5aa5095a0"><li><p id="d4277d48faab43c291c1c7b1627a34da">0 at index 0, as there are no non-zero entries above the first row.</p></li><li><p id="fae00fa876a240e2b860651cee027fb2">2 at index 1, as there are 2 non-zero entries above the second row ( 7 and 5 ).</p></li><li><p id="baaf19b39f7840e78bafc57f46b289db">2 at index 2, as there are still only 2 non-zero entries above the third row.</p></li><li><p id="c3c1949dca0b46159c521b4bc04d8891">4 at index 3, as there are now 4 non-zero entries above the fourth row (7, 5, 1, and 3).</p></li><li><p id="b8b6c892a57a4136826a9a51914ae52d">6 at index 4, as there are 6 non-zero entries in the matrix.</p></li></ol><p id="b29a23e8841d4b34990d9ab11d95d045">With this setting, note that the length of <code><![CDATA[data]]></code> and <code><![CDATA[col]]></code> are the number of non-zero entries in the matrix, while the length of <code><![CDATA[row]]></code> is always <em style="italic">m+1</em>. In addition, it is always the case that <code><![CDATA[row[0]]]></code> is 0 (because there are no non-zero entries above the first row) and <code><![CDATA[row[m]]]></code> is the number of non-zero entries in the matrix. In addition, the order is important, as entries that appear in earlier (above) rows need to be listed before those in later (below) rows.</p><p id="abdb5fdf1921452c9f9090bab064e8d7">This compressed row representation is what gives \xe2\x80\x9cCSR\xe2\x80\x9d its name, as the <em>rows are compressed to save space</em>. (Think about why this compresses the space, and in what cases this might not compress space in the sparse representation).</p><p id="a86d6bae7bb44bef8355ce7191a2be8c">This format allows for efficient row access and arithmetic operations (including elementwise matrix operations and matrix-vector products). For example, a matrix-vector product <em style="italic">Mx</em> involves computing the dot product between every row of <em style="italic">M</em> and <em style="italic">x</em>:</p><p id="cca3d80bf7b14a04bdc4ca191194be6b">\\[M x=\\left(M_{1} \\cdot x M_{2} \\cdot x \\quad \\ldots M_{m} \\cdot x\\right)^{\\top}\\]</p><p id="c7ac26dd8b0841789532e96fb27f49bc">We know that the non-zero entries in row <em style="italic">M</em><em style="italic"><sub>i</sub></em> are the ones at indices <code><![CDATA[(i, col[row[i]]), (i, col[row[i]+1]), \xe2\x80\xa6, (i, col[row[i+1]-1])]]></code>, so only these entries should be multiplied by the corresponding entries in x.</p><p id="f881ab5ae5414de7b9a63a2c4acc1057">At the same time, column access is slow with CSR, and conversion to other sparsity formats is generally (but not always) expensive. Consider the case where the number of elements is rather few. In this case, what is the time-complexity of conversion to COO?</p><section id="f83815e2e4774a81a3974b0edd36ba58"><title>Compressed Sparse Column Format (CSC)</title><body><p id="c3ceb895d05d406a9e892ed8bb0e4713">The CSC format behaves similarly to CSR, but with the columns being compressed instead of the rows, but in a very similar format. Its underlying representation consists of three lists:</p><ul id="e9ec9cb904f7498792628f72db7be35e"><li><p id="a2a668ae8b9e4fe8aec506f325faafd9"><code><![CDATA[data]]></code>: a list of the non-zero values in the matrix</p></li><li><p id="e69dbab0eab24317abb3813553723041"><code><![CDATA[col]]></code>: a list of <em style="italic">n+1</em> values, where <em style="italic">n</em> is the number of columns in the original matrix. </p><p id="ca202fc9f43a478d94c2ec850e951500"><code><![CDATA[col[i]]]></code> denotes the number of non-zero entries that appear in the columns before (to the left of) the i-th column in the original matrix</p></li><li><p id="e3a20e6362e84b6f88d23b1afe210976"><code><![CDATA[row]]></code>: a list of the row indices of the non-zero values.</p></li></ul><p id="fa98a1f22ecb4a52b390284648342335">With the example matrix A,</p><image id="a99142d01dcc46ff94e69ff316fb04aa" src="../webcontent/image-af9ea4c0e9c34b588972e5eeece43e58-4.png" alt="" style="inline" vertical-align="middle" height="179" width="315"><caption><p id="c98b315a9e384ec583be9d958e65387f" /></caption><popout enable="false"></popout></image><p id="c0fc8f1b47954e8685f9c210c4ae193e">its CSC representation is</p><codeblock id="e08b4be252764400aeac73d31cb8cf17" syntax="text" highlight="" number="false" start=""><![CDATA[data = [1, 7, 3, 8, 5, 2,]\ncol = [0, 1, 1, 3, 4, 6]\nrow = [2, 0, 2, 3, 0, 3]]]></codeblock><p id="f397cd46679f4f6b8755b7ed4afcf4b1">Similar to CSR, the order is important here, as entries that appear in earlier (left) columns need to be listed before those in later (right) columns.</p><p id="e003e0b77aad49cbadead5f039cc0a73">This format allows for efficient column access and arithmetic operations (including elementwise matrix operations and matrix-vector products, although CSR is faster for the latter). For example, a matrix-vector product <em style="italic">Mx</em> can also be expressed as a linear combination of the columns of <em style="italic">M</em>, where the coefficients are the entries in <em style="italic">x</em>:</p><p id="bc4feff2ae1a46af898246b7a67fe74c">\\[ M x=x_{1} M_{(1)}+x_{2} M_{(2)}+\\ldots+x_{n} M_{(n)} \\]</p><p id="c3ec0e5b0df8448b969fe8caaf334834">We know that the non-zero entries in column <em style="italic">M</em><em style="italic"><sub>(j)</sub></em> are the ones in indices <code><![CDATA[(j, row[col[j]]), (j, row[col[j]+1]), \xe2\x80\xa6, (j, row[col[j+1]-1])]]></code>, so only these entries should be multiplied with the corresponding entries in <code><![CDATA[x]]></code>.</p><p id="e9278e40817b4696a47b54a48cf1403f">At the same time, row access is slow with CSC, and conversion to other sparsity formats is, again, \xe2\x80\x9cgenerally\xe2\x80\x9d expensive. What\xe2\x80\x99s key here to note is, again, that in certain cases, conversions might be readily easy to do. As CSC and CSR compress rows and columns in a similar fashion, can you think of an example where converting between one to another does not require accessing the underlying data at all but just moving references?</p></body></section><section id="b30aca344e144de89846c1b41501427f"><title>Application of Sparse Matrices</title><body><p id="e2a5219028cd43bd9c5c171b0429fdd1">Here we provide a brief preview of how sparse matrices are used in different data science domains. We will discuss these domains in more detail in their corresponding modules later on.</p><p id="be95bd538e054e9ab057f54f0476c69e"><em>Natural Language Processing</em></p><p id="d5d8013434a542129bcb854e2226fba6">A crucial component of natural language processing is converting text data to numerical features which can then be used for subsequent modeling and training. Many techniques that perform this conversion yield feature vectors with very large dimensions but also high sparsity. For example, given a corpus <em style="italic">C</em>, the bag-of-word technique transforms an input document into a binary vector \\( v \\in\\{0,1\\}^{|C|} \\) where \\( v_{i} \\) is 1 if the i-th word in the corpus is present in the document. The size of this vector is the size of the corpus itself, which can easily reach tens of thousands for real-life documents.</p><p id="b1842595a7a545e78839cb48765a61e1"><em>Recommender Systems</em></p><p id="f6b5f5b3a4f84bf5b01010f816313bba">At the beginning of this module, we have mentioned the user-movie rating matrix as an example of a very large but sparse data structure. This kind of matrix data format is typically used as input to recommendation algorithms, which attempt to predict missing data based on present data (e.g., predict a user\xe2\x80\x99s rating of a movie they haven\xe2\x80\x99t rated, based on their past ratings of other movies). A standard technique for performing such predictions is <em style="italic">collaborative filtering</em>, which attempts to approximate the original user-movie rating matrix \\( X \\in R^{m \\times n} \\) as a product of two lower-ranked matrices <em style="italic">U</em> and <em style="italic">V</em>, i.e., \\( X \\approx U V \\) where \\( U \\in R^{m \\times k}, V \\in R^{k \\times n} \\) and \\( k \\ll m, n \\). This factorization involves complex computations over the rows and columns of <em style="italic">X</em>, which motivate the need to store <em style="italic">X</em> in a sparse format.</p><p id="ba6e160cddc94cd78f5908757cd370aa"><em>Sparse Modeling</em></p><p id="c170519fbfe0476db0218d0df02fe9f7">The sparse format is suitable for storing not only the input data but also model parameters in certain domains. For example, in computational biology, we typically need to build predictive models (e.g., linear regression, logistic regression) over a very large number of features. If, however, we expect that only a small subset of features carry predictive power, we can opt to store the model weights in a sparse vector/matrix format to optimize training and inference.</p></body></section></body></workbook_page>\n'